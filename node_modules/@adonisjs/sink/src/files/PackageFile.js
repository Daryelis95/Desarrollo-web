"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const mrm_core_1 = require("mrm-core");
const BaseFile_1 = require("../base/BaseFile");
class PackageFile extends BaseFile_1.BaseFile {
    constructor(basePath, _installerOutput = 'pipe') {
        super(basePath);
        this._installerOutput = _installerOutput;
        this.$actions = [];
        this.$install = [];
        this.$uninstall = [];
        this._useYarn = null;
        this.$cdIn();
        this.filePointer = mrm_core_1.packageJson();
        this.$cdOut();
    }
    _runHooks(action, list, dev) {
        if (action === 'install' && typeof (this._beforeInstall) === 'function') {
            this._beforeInstall(list, dev);
        }
        else if (action === 'uninstall' && typeof (this._beforeUninstall) === 'function') {
            this._beforeUninstall(list, dev);
        }
    }
    _setClient(options) {
        if (this._useYarn !== null) {
            options.yarn = this._useYarn;
        }
    }
    _installerFn(action, list, options) {
        if (!list.length) {
            return;
        }
        this._setClient(options);
        this._runHooks(action, list, options.dev);
        const fn = action === 'install' ? mrm_core_1.install : mrm_core_1.uninstall;
        return fn(list, options, (command, args) => {
            return child_process_1.spawnSync(command, args, {
                stdio: this._installerOutput,
            });
        });
    }
    _installerFnAsync(action, list, options) {
        return new Promise((resolve) => {
            if (!list.length) {
                resolve();
                return;
            }
            this._setClient(options);
            this._runHooks(action, list, options.dev);
            let response;
            const fn = action === 'install' ? mrm_core_1.install : mrm_core_1.uninstall;
            fn(list, options, (command, args) => {
                const runner = child_process_1.spawn(command, args, { stdio: 'pipe' });
                response = {
                    pid: runner.pid,
                    output: [],
                    stdout: Buffer.from(''),
                    stderr: Buffer.from(''),
                    status: null,
                    signal: null,
                };
                runner.stdout.on('data', (chunk) => {
                    response.stdout = Buffer.concat([response.stdout, chunk]);
                });
                runner.stderr.on('data', (chunk) => {
                    response.stderr = Buffer.concat([response.stderr, chunk]);
                });
                runner.on('close', (code, signal) => {
                    response.status = code;
                    response.signal = signal;
                    resolve(response);
                });
            });
        });
    }
    _commitDependencies(installs, uninstalls) {
        let response;
        for (let { list, versions, dev } of installs) {
            response = this._installerFn('install', list, { versions, dev });
            if (response && response.status === 1) {
                return response;
            }
        }
        for (let { list, dev } of uninstalls) {
            response = this._installerFn('uninstall', list, { dev });
            if (response && response.status === 1) {
                return response;
            }
        }
    }
    _rollbackDependencies(installs) {
        let response;
        for (let { list, dev } of installs) {
            response = this._installerFn('uninstall', list, { dev });
            if (response && response.status === 1) {
                return response;
            }
        }
    }
    async _commitDependenciesAsync(installs, uninstalls) {
        let response;
        for (let { list, versions, dev } of installs) {
            response = await this._installerFnAsync('install', list, { versions, dev });
            if (response && response.status === 1) {
                return response;
            }
        }
        for (let { list, dev } of uninstalls) {
            response = await this._installerFnAsync('uninstall', list, { dev });
            if (response && response.status === 1) {
                return response;
            }
        }
    }
    async _rollbackDependenciesAsync(installs) {
        let response;
        for (let { list, dev } of installs) {
            response = await this._installerFnAsync('uninstall', list, { dev });
            if (response && response.status === 1) {
                return response;
            }
        }
    }
    _commitActions() {
        const actions = this.$getCommitActions();
        const deleteFile = actions.find(({ action }) => action === 'delete');
        if (deleteFile) {
            this.filePointer.delete();
            this.$cdOut();
            return false;
        }
        actions.forEach(({ action, body }) => {
            if (['set', 'unset'].indexOf(action) > -1) {
                this.filePointer[action](body.key, body.value);
                return;
            }
            if (['prependScript', 'appendScript', 'setScript', 'removeScript'].indexOf(action) > -1) {
                this.filePointer[action](body.name, body.script);
                return;
            }
        });
        this.filePointer.save();
        return true;
    }
    _rollbackActions() {
        const actions = this.$getCommitActions();
        actions.forEach(({ action, body }) => {
            if (action === 'set') {
                this.filePointer.unset(body.key);
                return;
            }
            if (action === 'setScript') {
                this.filePointer.removeScript(body.name);
                return;
            }
            if (['prependScript', 'appendScript'].indexOf(action) > -1) {
                this.filePointer.removeScript(body.name, new RegExp(body.script));
                return;
            }
        });
        this.filePointer.save();
        return true;
    }
    set(key, value) {
        this.$addAction('set', { key, value });
        return this;
    }
    yarn(useYarn) {
        this._useYarn = useYarn;
        return this;
    }
    unset(key) {
        this.$addAction('unset', { key });
        return this;
    }
    setScript(name, script) {
        this.$addAction('setScript', { name, script });
        return this;
    }
    appendScript(name, script) {
        this.$addAction('appendScript', { name, script });
        return this;
    }
    prependScript(name, script) {
        this.$addAction('prependScript', { name, script });
        return this;
    }
    removeScript(name, script) {
        this.$addAction('removeScript', { name, script });
        return this;
    }
    install(dependency, version = 'latest', dev = true) {
        this.$install.push({ dependency, version, dev });
        return this;
    }
    uninstall(dependency, dev = true) {
        this.$uninstall.push({ dependency, dev });
        return this;
    }
    delete() {
        this.$addAction('delete');
        return this;
    }
    get(address, defaultValue) {
        return address ? this.filePointer.get(address, defaultValue) : this.filePointer.get();
    }
    exists() {
        return this.filePointer.exists();
    }
    getInstalls(dev = true) {
        const dependencies = { versions: {}, list: [], dev };
        return this.$install.reduce((result, dependency) => {
            if (dependency.dev && dev) {
                result.list.push(dependency.dependency);
                if (dependency.version !== 'latest') {
                    result.versions[dependency.dependency] = dependency.version;
                }
            }
            else if (!dependency.dev && !dev) {
                result.list.push(dependency.dependency);
                if (dependency.version !== 'latest') {
                    result.versions[dependency.dependency] = dependency.version;
                }
            }
            return result;
        }, dependencies);
    }
    getUninstalls(dev) {
        const dependencies = { list: [], dev };
        return this.$uninstall.reduce((result, dependency) => {
            if (dependency.dev && dev) {
                result.list.push(dependency.dependency);
            }
            else if (!dependency.dev && !dev) {
                result.list.push(dependency.dependency);
            }
            return result;
        }, dependencies);
    }
    beforeInstall(callback) {
        this._beforeInstall = callback;
        return this;
    }
    beforeUninstall(callback) {
        this._beforeUninstall = callback;
        return this;
    }
    commit() {
        this.$cdIn();
        const success = this._commitActions();
        if (!success) {
            return;
        }
        const response = this._commitDependencies([this.getInstalls(true), this.getInstalls(false)], [this.getUninstalls(true), this.getUninstalls(false)]);
        this.$cdOut();
        return response;
    }
    async commitAsync() {
        this.$cdIn();
        const success = this._commitActions();
        if (!success) {
            return;
        }
        const response = await this._commitDependenciesAsync([this.getInstalls(true), this.getInstalls(false)], [this.getUninstalls(true), this.getUninstalls(false)]);
        this.$cdOut();
        return response;
    }
    rollback() {
        this.$cdIn();
        const success = this._rollbackActions();
        if (!success) {
            return;
        }
        const response = this._rollbackDependencies([
            this.getInstalls(true),
            this.getInstalls(false),
        ]);
        this.$cdOut();
        return response;
    }
    async rollbackAsync() {
        this.$cdIn();
        const success = this._rollbackActions();
        if (!success) {
            return;
        }
        const response = await this._rollbackDependenciesAsync([
            this.getInstalls(true),
            this.getInstalls(false),
        ]);
        this.$cdOut();
        return response;
    }
}
exports.PackageFile = PackageFile;
