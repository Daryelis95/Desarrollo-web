"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@poppinss/utils");
const path_1 = require("path");
const logger_1 = require("./logger");
async function executeInstructions(packageName, projectRoot, application) {
    const sink = await Promise.resolve().then(() => __importStar(require('../index')));
    const packagePath = require.resolve(`${packageName}/package.json`, { paths: [projectRoot] });
    const pkg = require(packagePath);
    if (!pkg.adonisjs) {
        return true;
    }
    if (pkg.adonisjs.instructions) {
        const normalizedPath = path_1.normalize(`${packageName}/${pkg.adonisjs.instructions}`);
        const instructionsPath = require.resolve(normalizedPath, { paths: [projectRoot] });
        const instructions = utils_1.esmRequire(instructionsPath);
        await instructions(projectRoot, application, sink);
    }
    if (pkg.adonisjs.templates) {
        const templatesRoot = path_1.join(path_1.dirname(packagePath), pkg.adonisjs.templates.basePath || './build/templates');
        sink.copyTemplates(projectRoot, application, templatesRoot, pkg.adonisjs.templates);
    }
    if (pkg.adonisjs.env) {
        const env = new sink.EnvFile(projectRoot);
        Object.keys(pkg.adonisjs.env).forEach((key) => env.set(key, pkg.adonisjs.env[key]));
        env.commit();
        logger_1.logger.update('.env');
    }
    if (pkg.adonisjs.types) {
        const tsConfig = new sink.JsonFile(projectRoot, 'tsconfig.json');
        const types = tsConfig.get('compilerOptions.types') || [];
        if (!types.find((type) => type.includes(pkg.adonisjs.types))) {
            types.push(pkg.adonisjs.types);
            tsConfig.set('compilerOptions.types', types);
            tsConfig.commit();
            logger_1.logger.update('tsconfig.json');
        }
    }
    if (Array.isArray(pkg.adonisjs.commands)) {
        const adonisRcFile = new sink.RcFile(projectRoot);
        pkg.adonisjs.commands.forEach((command) => {
            adonisRcFile.addCommand(command);
        });
        adonisRcFile.commit();
        logger_1.logger.update('.adonisrc.json');
    }
    if (pkg.adonisjs.instructionsMd) {
        await sink.renderMarkdown(path_1.join(path_1.dirname(packagePath), pkg.adonisjs.instructionsMd), packageName);
    }
    return true;
}
exports.executeInstructions = executeInstructions;
