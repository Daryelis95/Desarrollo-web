"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const resolve_from_1 = __importDefault(require("resolve-from"));
const fs_1 = require("fs");
const utils_1 = require("@poppinss/utils");
const path_1 = require("path");
const validateCommand_1 = require("../utils/validateCommand");
const CommandValidationException_1 = require("../Exceptions/CommandValidationException");
const MissingManifestFileException_1 = require("../Exceptions/MissingManifestFileException");
class Manifest {
    constructor(_basePath) {
        this._basePath = _basePath;
    }
    _writeManifest(manifest) {
        return new Promise((resolve, reject) => {
            fs_1.writeFile(path_1.join(this._basePath, 'ace-manifest.json'), JSON.stringify(manifest), (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    loadCommand(commandPath) {
        const absPath = resolve_from_1.default(this._basePath, commandPath);
        const command = utils_1.esmRequire(absPath);
        if (!command.name) {
            throw CommandValidationException_1.CommandValidationException.invalidManifestExport(commandPath);
        }
        command.$boot();
        return command;
    }
    lookupCommands(commandPath) {
        if (path_1.isAbsolute(commandPath)) {
            throw new Error('Absolute path to commands are not allowed, since manifest file needs to be portable');
        }
        const absPath = resolve_from_1.default(this._basePath, commandPath);
        const commandOrCommands = utils_1.esmRequire(absPath);
        if (Array.isArray(commandOrCommands)) {
            return commandOrCommands.map((commandPath) => {
                return this.loadCommand(commandPath);
            });
        }
        return [this.loadCommand(commandPath)];
    }
    async generate(commandPaths) {
        const manifest = commandPaths.reduce((manifest, commandPath) => {
            const commands = this.lookupCommands(commandPath);
            commands.forEach((command) => {
                validateCommand_1.validateCommand(command);
                manifest[command.commandName] = {
                    settings: command.settings || {},
                    commandPath: commandPath.replace(new RegExp(`${path_1.extname(commandPath)}$`), ''),
                    commandName: command.commandName,
                    description: command.description,
                    args: command.args,
                    flags: command.flags,
                };
            });
            return manifest;
        }, {});
        await this._writeManifest(manifest);
    }
    load() {
        return new Promise((resolve, reject) => {
            fs_1.readFile(path_1.join(this._basePath, 'ace-manifest.json'), 'utf-8', (error, contents) => {
                if (error) {
                    if (error.code === 'ENOENT') {
                        reject(MissingManifestFileException_1.MissingManifestFileException.invoke());
                    }
                    else {
                        reject(error);
                    }
                }
                else {
                    resolve(JSON.parse(contents));
                }
            });
        });
    }
}
exports.Manifest = Manifest;
