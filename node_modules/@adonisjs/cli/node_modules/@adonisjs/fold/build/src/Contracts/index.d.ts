/// <reference types="node" />
import { EventEmitter } from 'events';
export interface TracerContract extends EventEmitter {
    in(namespace: string, cached: boolean): void;
    out(): void;
}
export declare type IocResolverLookupNode = {
    namespace: string;
    type: 'binding' | 'autoload';
    method: string;
};
export interface IocResolverContract {
    resolve(namespace: string, prefixNamespace?: string): IocResolverLookupNode;
    call<T extends any>(namespace: string | IocResolverLookupNode, prefixNamespace?: string, args?: any[]): T;
}
export interface IocContract {
    tracer: TracerContract;
    autoloads: {
        [namespace: string]: string;
    };
    autoloadedAliases: string[];
    useProxies(): this;
    bind(namespace: string, callback: BindCallback): void;
    singleton(namespace: string, callback: BindCallback): void;
    alias(namespace: string, alias: string): void;
    autoload(directoryPath: string, namespace: string): void;
    clearAutoloadCache(namespace?: string, clearRequireCache?: boolean): void;
    fake(namespace: string, callback: BindFakeCallback): void;
    use<T extends any = any>(namespace: string | LookupNode): T;
    make<T extends any = any>(namespace: string | LookupNode, args?: string[]): T;
    useFake<T extends any = any>(namespace: string, value?: any): T;
    hasFake(namespace: string): boolean;
    hasAlias(namespace: string): boolean;
    hasBinding(namespace: string, checkAliases?: boolean): boolean;
    getAliasNamespace(namespace: string): string | undefined;
    isAutoloadNamespace(namespace: string): boolean;
    getAutoloadBaseNamespace(namespace: string): string | undefined;
    restore(namespace: string): void;
    with(namespaces: string[], cb: (...args: any[]) => void): void;
    call<T extends object, K extends keyof T = any>(target: T, method: K, args: any[]): any;
    lookup(namespace: string, prefixNamespace?: string): LookupNode | null;
    getResolver(fallbackMethod?: string, rcNamespaceKey?: string, fallbackNamespace?: string): IocResolverContract;
}
export declare type Binding = {
    callback: BindCallback;
    singleton: boolean;
    cachedValue?: unknown;
};
export declare type FakeBinding = {
    callback: BindFakeCallback;
    cachedValue?: unknown;
};
export declare type LookupNode = {
    namespace: string;
    type: 'binding' | 'autoload';
};
export declare type AutoloadCacheItem = {
    diskPath: string;
    cachedValue: any;
};
export declare type BindCallback = (app: IocContract) => unknown;
export declare type BindFakeCallback = (app: IocContract, value?: any) => unknown;
