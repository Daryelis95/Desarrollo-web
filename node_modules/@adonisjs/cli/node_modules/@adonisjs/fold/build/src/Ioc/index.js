"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
const Tracer_1 = __importDefault(require("./Tracer"));
const Injector_1 = require("./Injector");
const Resolver_1 = require("../Resolver");
const IoCProxy_1 = require("./IoCProxy");
const IocLookupException_1 = require("../Exceptions/IocLookupException");
const helpers_1 = require("../helpers");
class Ioc {
    constructor(_emitEvents = false) {
        this._emitEvents = _emitEvents;
        this.tracer = Tracer_1.default(this._emitEvents);
        this.autoloads = {};
        this.autoloadedAliases = [];
        this._autoloadsCache = new Map();
        this._aliases = {};
        this._bindings = {};
        this._fakes = new Map();
        this._useProxies = false;
        this._injector = new Injector_1.Injector(this);
    }
    _resolveBinding(namespace) {
        const binding = this._bindings[namespace];
        if (!binding) {
            throw IocLookupException_1.IocLookupException.missingBinding(namespace);
        }
        this.tracer.in(namespace, !!binding.cachedValue);
        let value;
        if (binding.singleton && binding.cachedValue !== undefined) {
            value = binding.cachedValue;
        }
        else if (binding.singleton) {
            value = binding.cachedValue = binding.callback(this);
        }
        else {
            value = binding.callback(this);
        }
        this.tracer.out();
        return value;
    }
    _autoload(namespace) {
        const cacheEntry = this._autoloadsCache.get(namespace);
        this.tracer.in(namespace, !!cacheEntry);
        if (cacheEntry) {
            this.tracer.out();
            return cacheEntry.cachedValue;
        }
        const baseNamespace = this.getAutoloadBaseNamespace(namespace);
        const diskPath = namespace.replace(baseNamespace, this.autoloads[baseNamespace]);
        const absPath = require.resolve(path_1.normalize(diskPath));
        this._autoloadsCache.set(namespace, { diskPath: absPath, cachedValue: require(absPath) });
        this.tracer.out();
        return this._autoloadsCache.get(namespace).cachedValue;
    }
    _resolve(node) {
        switch (node.type) {
            case 'binding':
                return this._resolveBinding(node.namespace);
            case 'autoload':
                return this._autoload(node.namespace);
        }
    }
    _resolveAndMake(node, args) {
        switch (node.type) {
            case 'binding':
                return this._resolveBinding(node.namespace);
            case 'autoload':
                let value = this._autoload(node.namespace);
                value = helpers_1.isEsm(value) && value.default ? value.default : value;
                return this._injector.injectDependencies(value, args || []);
        }
    }
    _removeAutoloadFromCache(namespace, removeRequire) {
        const item = this._autoloadsCache.get(namespace);
        if (!item) {
            return;
        }
        this._autoloadsCache.delete(namespace);
        if (removeRequire) {
            helpers_1.clearRequireCache(item.diskPath);
        }
    }
    _wrapAsProxy(namespace, value) {
        if (helpers_1.isObject(value)) {
            return new IoCProxy_1.IoCProxyObject(namespace, value, this);
        }
        if (helpers_1.isClass(value)) {
            return IoCProxy_1.IocProxyClass(namespace, value, this);
        }
        return value;
    }
    _isLookupNode(value) {
        return value && value.type && value.namespace;
    }
    useProxies(enable = true) {
        this._useProxies = !!enable;
        return this;
    }
    bind(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.bind expect 2nd argument to be a function');
        this.tracer.emit('bind', { namespace, singleton: false });
        this._bindings[namespace] = { callback, singleton: false };
    }
    singleton(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.singleton expect 2nd argument to be a function');
        this.tracer.emit('bind', { namespace, singleton: true });
        this._bindings[namespace] = { callback, singleton: true };
    }
    alias(namespace, alias) {
        this.tracer.emit('alias', { alias, namespace });
        this._aliases[alias] = namespace;
    }
    autoload(directoryPath, namespace) {
        this.tracer.emit('autoload', { directoryPath, namespace });
        this.autoloadedAliases.push(namespace);
        this.autoloads[namespace] = directoryPath;
    }
    clearAutoloadCache(namespace, clearRequireCache = false) {
        if (!namespace) {
            Array.from(this._autoloadsCache.keys()).forEach((key) => {
                this._removeAutoloadFromCache(key, clearRequireCache);
            });
            return;
        }
        this._removeAutoloadFromCache(namespace, clearRequireCache);
    }
    fake(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.fake expect 2nd argument to be a function');
        this.tracer.emit('fake', { namespace });
        this._fakes.set(namespace, { callback });
    }
    use(node) {
        const lookedupNode = typeof (node) === 'string' ? this.lookup(node) : node;
        if (!lookedupNode || !lookedupNode.type) {
            throw IocLookupException_1.IocLookupException.lookupFailed(node);
        }
        let value = this._resolve(lookedupNode);
        if (!this._useProxies) {
            return value;
        }
        if (helpers_1.isEsm(value)) {
            if (value.default) {
                value = Object.assign({}, value, {
                    default: this._wrapAsProxy(lookedupNode.namespace, value.default),
                });
            }
            return value;
        }
        return this._wrapAsProxy(lookedupNode.namespace, value);
    }
    make(node, args) {
        if (typeof (node) !== 'string' && !this._isLookupNode(node)) {
            return this._injector.injectDependencies(node, args || []);
        }
        const lookedupNode = typeof (node) === 'string' ? this.lookup(node) : node;
        if (!lookedupNode || !lookedupNode.type) {
            throw IocLookupException_1.IocLookupException.lookupFailed(node);
        }
        const value = this._resolveAndMake(lookedupNode || node, args);
        if (!this._useProxies || helpers_1.isEsm(value)) {
            return value;
        }
        return this._wrapAsProxy(lookedupNode.namespace, value);
    }
    useFake(namespace, value) {
        const fake = this._fakes.get(namespace);
        if (!fake) {
            throw new Error(`Cannot find fake for ${namespace}`);
        }
        fake.cachedValue = fake.cachedValue || fake.callback(this, value);
        return fake.cachedValue;
    }
    hasFake(namespace) {
        return this._fakes.has(namespace);
    }
    hasAlias(namespace) {
        return !!this._aliases[namespace];
    }
    hasBinding(namespace, checkAliases = false) {
        const binding = this._bindings[namespace];
        if (!binding && checkAliases) {
            return !!this._bindings[this.getAliasNamespace(namespace)];
        }
        return !!binding;
    }
    getAliasNamespace(namespace) {
        return this._aliases[namespace];
    }
    isAutoloadNamespace(namespace) {
        return !!this.getAutoloadBaseNamespace(namespace);
    }
    getAutoloadBaseNamespace(namespace) {
        return this.autoloadedAliases.find((alias) => namespace.startsWith(`${alias}/`));
    }
    restore(name) {
        this._fakes.delete(name);
    }
    with(namespaces, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.with expect 2nd argument to be a function');
        if (namespaces.every((namespace) => this.hasBinding(namespace, true))) {
            callback(...namespaces.map((namespace) => this.use(namespace)));
        }
    }
    call(target, method, args) {
        if (typeof (target[method]) !== 'function') {
            throw new Error(`Missing method ${method} on ${target.constructor.name}`);
        }
        return this._injector.injectMethodDependencies(target, method, args || []);
    }
    lookup(namespace, prefixNamespace) {
        if (!namespace) {
            throw new utils_1.Exception('Empty string cannot be used as IoC container reference', 500, 'E_INVALID_IOC_NAMESPACE');
        }
        if (namespace.startsWith('/')) {
            namespace = namespace.substr(1);
        }
        else if (prefixNamespace) {
            namespace = `${prefixNamespace.replace(/\/$/, '')}/${namespace}`;
        }
        if (this.hasBinding(namespace)) {
            return {
                type: 'binding',
                namespace,
            };
        }
        if (this.hasAlias(namespace)) {
            return {
                type: 'binding',
                namespace: this.getAliasNamespace(namespace),
            };
        }
        if (this.isAutoloadNamespace(namespace)) {
            return {
                type: 'autoload',
                namespace: namespace,
            };
        }
        return null;
    }
    getResolver(fallbackMethod, rcNamespaceKey, fallbackNamespace) {
        return new Resolver_1.IocResolver(this, fallbackMethod, rcNamespaceKey, fallbackNamespace);
    }
}
exports.Ioc = Ioc;
