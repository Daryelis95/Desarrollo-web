import { IocResolver } from '../Resolver';
import { IocContract, BindCallback, BindFakeCallback, LookupNode } from '../Contracts';
export declare class Ioc implements IocContract {
    private _emitEvents;
    tracer: import("./Tracer").Tracer;
    autoloads: {
        [namespace: string]: string;
    };
    autoloadedAliases: string[];
    private _autoloadsCache;
    private _aliases;
    private _bindings;
    private _fakes;
    private _useProxies;
    private _injector;
    constructor(_emitEvents?: boolean);
    private _resolveBinding;
    private _autoload;
    private _resolve;
    private _resolveAndMake;
    private _removeAutoloadFromCache;
    private _wrapAsProxy;
    private _isLookupNode;
    useProxies(enable?: boolean): this;
    bind(namespace: string, callback: BindCallback): void;
    singleton(namespace: string, callback: BindCallback): void;
    alias(namespace: string, alias: string): void;
    autoload(directoryPath: string, namespace: string): void;
    clearAutoloadCache(namespace?: string, clearRequireCache?: boolean): void;
    fake(namespace: string, callback: BindFakeCallback): void;
    use<T extends any = any>(node: string | LookupNode): T;
    make<T extends any = any>(node: any, args?: string[]): T;
    useFake<T extends any = any>(namespace: string, value?: any): T;
    hasFake(namespace: string): boolean;
    hasAlias(namespace: string): boolean;
    hasBinding(namespace: string, checkAliases?: boolean): boolean;
    getAliasNamespace(namespace: string): string | undefined;
    isAutoloadNamespace(namespace: string): boolean;
    getAutoloadBaseNamespace(namespace: string): string | undefined;
    restore(name: string): void;
    with(namespaces: string[], callback: (...args: any[]) => void): void;
    call<T extends object, K extends keyof T = any>(target: T, method: K, args?: any[]): any;
    lookup(namespace: string, prefixNamespace?: string): null | LookupNode;
    getResolver(fallbackMethod?: string, rcNamespaceKey?: string, fallbackNamespace?: string): IocResolver;
}
